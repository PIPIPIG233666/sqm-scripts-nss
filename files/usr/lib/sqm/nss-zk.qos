#!/bin/sh
###############################################################################
# nss-zk.qos (HW Accelerated Simple Traffic Shaper)
# version 20240226
#
# Requires: Platform IPQ807x, iproute2, tc (or tc-tiny), kmod-qca-nss-drv-qdisc,
# and kmod-qca-nss-drv-igs.
#
# Maintainer: Qosmio (https://forum.openwrt.org/u/qosmio)
# NSS Packages Repository: https://github.com/qosmio/nss-packages (branch: NSS-12.4-K6.1)
# NSS SQM Repository: https://github.com/qosmio/sqm-scripts-nss
#
# Derived from work by @michaelchen644 (https://forum.openwrt.org/u/michaelchen644) and
# @rickkdotnet (https://github.com/rickkdotnet/sqm-scripts-nss)
#

. /lib/functions.sh

. "$SQM_LIB_DIR"/defaults.sh

DEV=ifb-nss

if [ -n "${ACTION}" ] && [ -n "${INTERFACE}" ] && [ -n "${DEVICE}" ]; then
  sqm_debug "${SCRIPT}: triggered by hotplug ${ACTION} for ${INTERFACE} (${DEVICE})"
  if $TC qdisc show dev $DEV; then
    sqm_log "${SCRIPT}: TC qdisc is already installed on $DEV, not restarting to minimize the risk of crashes"
    exit 0
  else
    sqm_debug "${SCRIPT}: No qdisc detected on $DEV, continuing with script"
  fi
fi

# the maximum (worst case) length of the fq_codel queue in milliseconds
# this is used together with speed and mtu to calculate the fq_codel queue limit
# when the limit is not specified by the user in the SQM configuration
#
# If the queue limit of the $DEV is hit (observable by looking at drop_overlimit in tc -s qdisc show dev $DEV)
# I see bloat for the first few seconds of a load test until codel takes over and things stabilize.
MAXQLIMIT_MS=100

check_wan() {
  local wan_ip
  # use ubus to check for WAN IP
  wan_ip=$(ubus call network.interface.wan status | jsonfilter -e '@["ipv4-address"][0].address')
  if [ -z "$wan_ip" ]; then
    sqm_debug "check_wan: NO IP on WAN. Sleeping 5 seconds..."
    sleep 5
    check_wan
  else
    sqm_debug "check_wan: IP on WAN: $wan_ip"
  fi
}

calc_limit() {
  [ -z ${MINLIMIT} ] && MINLIMIT=200
  local LIMIT

  # queue-limit = (bandwidth / 8 bits) * delay / MTU
  LIMIT=$(awk -v SPEED=$1 -v MTU=$2 -v MAXDELAY=$3 'BEGIN {print(int((SPEED*125)*(MAXDELAY/1000)/MTU))}')
  sqm_debug "calc_limit: Queue limit should be $LIMIT packets for speed $1, MTU $2 and maximum delay $3 ms"

  if [ ${LIMIT} -lt ${MINLIMIT} ]; then
    LIMIT=${MINLIMIT}
    sqm_debug "calc_limit: calculated limit is lower than ${MINLIMIT}, this is too little for codel to work with. Raising to ${MINLIMIT}."
  fi

  echo $LIMIT

}

cake_egress() {
    sqm_error "The NSS shaper is currently only compatible with fq_codel. Not doing anything."
    return 1
}

cake_ingress() {
    sqm_error "The NSS shaper is currently only compatible with fq_codel. Not doing anything."
    return 1
}

get_ecn() {
  CURECN=$1
  case $CURECN in
    ECN)
      case $QDISC in
        *codel | *pie | *red)
          CURECN=ecn
          ;;
        *)
          CURECN=""
          ;;
      esac
      ;;

    NOECN)
      case $QDISC in
        *codel | *pie | *red)
          CURECN=""
          ;;
        *)
          CURECN=""
          ;;
      esac
      ;;

    *) sqm_warn "ecn value $1 not handled" ;;
  esac
  sqm_debug "get_ECN: $1 CURECN: $CURECN IECN: $IECN EECN: $EECN"
  echo "$CURECN"
}

# Sets up the NSS fq_codel qdisc
add_nssfq_codel() {

  local IFACE=$1
  local SPEED=$2
  local TARGET=$3
  local LIMIT=$4
  local MTU=$5
  local QDISC_OPTS=$6
  local LOGT="add_nssfq_codel $IFACE:"

  sqm_debug "$LOGT interface:$IFACE speed:$SPEED target:$TARGET limit:$LIMIT mtu:$MTU overhead:$OVERHEAD opts:$QDISC_OPTS"

  # INTERVAL
  #
  # this allows you to set the codel interval via (l)uci eqdisc_opts
  # You should set this to the average "worst case" latency towards your services
  # if no interval statement is present, set a sensible default
  if [[ "${QDISC_OPTS}" != *"interval"* ]]; then
    sqm_debug "$LOGT No interval specified via advanced option string, going with 100ms"

    # 100ms works well in most cases, unless the link speed is so slow that target > interval
    # but you probably don't want/need NSS in that case anyway, so I don't bother.
    QDISC_OPTS="interval 100ms ${QDISC_OPTS}"
  fi

  # QUANTUM
  #
  # Quantum defines how much bytes may be dequeued at once. At MTU, all packets have equal weight
  # but lower quantums give smaller packets more weight. I.e. with a quantum of 300, a <300 byte
  # packet is 5 times likelier to be dequeued than a 1500 byte packet.
  # At high rates this doesn't make much difference but at low speeds it does

  if [[ "${QDISC_OPTS}" != *"quantum"* ]]; then

    # use the interface mtu, this seems to work well in almost all cases
    # add 14 bytes for the ethernet header and 4 bytes for NSS
    let QUANTUM=MTU

    sqm_debug "$LOGT No quantum specified via advanced option string, setting default to $QUANTUM based on an MTU of $MTU"

    # at speeds <100Mb, a quantum of ~300 helps prioritize small packets
    # https://www.bufferbloat.net/projects/codel/wiki/Best_practices_for_benchmarking_Codel_and_FQ_Codel/
    if [ ${SPEED} -lt 100000 ]; then
      let QUANTUM/=5
      let QUANTUM+=1
      sqm_debug "Interface speed is less than 100 Mb/s, lowering Codel quantum to $QUANTUM"
    fi

    QDISC_OPTS="$(get_quantum ${QUANTUM}) ${QDISC_OPTS}"
  fi

  # FLOWS
  #
  # The number of flows into which packets are classified
  # required argument for nssfq_codel
  if [[ "${QDISC_OPTS}" != *"flows"* ]]; then
    QDISC_OPTS="flows 1024 ${QDISC_OPTS}"
  fi

  # Add the qdisc to the interface
  $TC qdisc add dev $IFACE parent 10:3 handle 300: nssfq_codel $(get_limit "$LIMIT") $(get_target "$TARGET" "$SPEED") ${QDISC_OPTS} set_default accel_mode 0

  return 0
}

egress() {
  # sleep 30s
  MTU=$(get_mtu $IFACE)

  # Codel target interval, when not set use a reasonable default
  [ -z "$ETARGET" ] && ETARGET="5ms"

  # if we leave this empty the qdisc uses a default of 1514. However, when you enable NSS
  # maxpacket in tc -s qdisc will show that 1518b packets are hitting the shaper, which is probably due to a header
  # added by NSS. Not sure what is correct, but it's probably better to err on the large side
  # If you don't like this, just set the overhead in the SQM config to 0 or 14.
  [ "${OVERHEAD}" -eq 0 ] && OVERHEAD=18

  let MTU+=OVERHEAD

  # If there's no queue limit configured, calculate one
  [ -z "$ELIMIT" ] && ELIMIT=$(calc_limit ${UPLINK} ${MTU} ${MAXQLIMIT_MS})

  if tc qdisc show dev $IFACE root 2>/dev/null 1>&2; then
    $TC qdisc del dev $IFACE root
  fi

  BURST=$(get_burst "${MTU:-1514}" "$UPLINK" "$ESHAPER_BURST_DUR_US")
  BURST=${BURST:-1514}
  UPLINK100=$((UPLINK / 10))
  UPLINK200=$((UPLINK * 4 / 10))
  BURST100=$((BURST / 10))
  BURST200=$((BURST * 3 / 10))

  $TC qdisc add dev $IFACE root handle 1: nsstbl rate "${UPLINK}"kbit burst "$BURST" mtu "$MTU" accel_mode 0
  $TC qdisc add dev $IFACE parent 1: handle 10: nssprio bands 3 accel_mode 0
  $TC qdisc add dev $IFACE parent 10:1 handle 100: nsstbl rate ${UPLINK100}kbit burst $BURST100 accel_mode 0
  $TC qdisc add dev $IFACE parent 100: handle 1000: nsspfifo limit 100 accel_mode 0
  $TC qdisc add dev $IFACE parent 10:2 handle 200: nsstbl rate ${UPLINK200}kbit burst $BURST200 accel_mode 0
  $TC qdisc add dev $IFACE parent 200: handle 2000: nssred limit 100k min 30k max 80k avpkt 1k burst 55 $(get_ecn "$EECN") probability 0.50 accel_mode 0
  add_nssfq_codel ${IFACE} ${UPLINK} ${ETARGET} ${ELIMIT} ${MTU} "${EQDISC_OPTS}" || (sqm_error "egress: failed to add qdisc" && return 1)
  return 0
}

ingress() {
  # Codel target interval, when not set use a reasonable default
  [ -z "$ITARGET" ] && ITARGET="5ms"

  # MTU, see egress for more info
  local MTU=$(get_mtu $IFACE)

  [ "${OVERHEAD}" -eq 0 ] && OVERHEAD=18
  let MTU+=OVERHEAD

  # If there's no queue limit configured, calculate one
  [ -z "$ILIMIT" ] && ILIMIT=$(calc_limit ${DOWNLINK} ${MTU} ${MAXQLIMIT_MS})

  if tc qdisc show dev $IFACE 2>&1 | awk '$2=="ingress"{print}'|grep -q .; then
    $TC qdisc del dev $IFACE ingress
  fi

  if tc qdisc show dev $DEV root 2>/dev/null 1>&2; then
    $TC qdisc del dev $DEV root
  fi

  BURST=$(get_burst "${MTU:-1514}" "$DOWNLINK" "$ISHAPER_BURST_DUR_US")
  BURST=${BURST:-1514}
  DOWNLINK100=$((DOWNLINK / 10))
  DOWNLINK200=$((DOWNLINK * 4 / 10))
  BURST100=$((BURST / 10))
  BURST200=$((BURST * 3 / 10))

  $IP link add name $DEV type ifb
  $IP link set dev $DEV up

  $TC qdisc add dev $IFACE handle ffff: ingress
  $TC filter add dev $IFACE parent ffff: protocol all u32 match u32 0 0 action nssmirred redirect dev $DEV fromdev $IFACE
  $TC qdisc add dev $DEV root handle 1: nsstbl rate "${DOWNLINK}"kbit burst "$BURST" mtu "$MTU" accel_mode 0
  $TC qdisc add dev $DEV parent 1: handle 10: nssprio bands 3 accel_mode 0
  $TC qdisc add dev $DEV parent 10:1 handle 100: nsstbl rate "${DOWNLINK100}"kbit burst $BURST100 accel_mode 0
  $TC qdisc add dev $DEV parent 100: handle 1000: nsspfifo limit 100 accel_mode 0
  $TC qdisc add dev $DEV parent 10:2 handle 200: nsstbl rate "${DOWNLINK200}"kbit burst $BURST200 accel_mode 0
  $TC qdisc add dev $DEV parent 200: handle 2000: nssred limit 100k min 30k max 80k avpkt 1k burst 55 $(get_ecn "${IECN}") probability 0.50 accel_mode 0

  add_nssfq_codel ${DEV} ${DOWNLINK} ${ITARGET} ${ILIMIT} ${MTU} "${IQDISC_OPTS}" || (sqm_error "ingress: failed to add shaper" && return 1)

  return 0
}

sqm_prepare_script() {
  for module in qca_nss_qdisc act_nssmirred; do
    if [ ! -d /sys/module/$module ]; then
      sqm_log "sqm_prepare_script: loading required kernel module: $module"
      modprobe -v $module 2>>${OUTPUT_TARGET} || { sqm_error "Kernel module failed to load" ; return 1; }
    fi
  done
  return 0
}

sqm_start() {
    sqm_debug "sqm_start: Starting sqm_start from nss.qos"

    [ -n "$IFACE" ] || return

    # reset the iptables trace log
    ipt_log_restart

    check_wan

    sqm_prepare_script

    if [ "${UPLINK}" -ne 0 ];
    then
      CUR_DIRECTION="egress"
      if fn_exists egress && egress;
      then
        sqm_log "sqm_start: egress shaping activated"
      else
        sqm_warn "sqm_start: ${SCRIPT} lacks egress() function or exited with an error"
      fi
    else
      SILENT=1 $TC qdisc del dev ${IFACE} root
      sqm_log "sqm_start: egress shaping deactivated"
    fi

    if [ "${DOWNLINK}" -ne 0 ];
    then
      CUR_DIRECTION="ingress"
      if fn_exists ingress && ingress;
      then
        sqm_log "sqm_start: ingress shaping activated"
      else
        sqm_warn "sqm_start: ${SCRIPT} lacks ingress() function or exited with an error"
      fi
    else
      SILENT=1 $TC qdisc del dev ${DEV} root
      sqm_log "sqm_start: ingress shaping deactivated"
    fi

    return 0
}

sqm_stop() {

  if [ "$(tc qdisc show dev $IFACE root 2>&1 | awk -F':| ' 'NR==1{print $3}')" -gt 0 ]; then
    $TC qdisc del dev $IFACE root
  fi

  if tc qdisc show dev $IFACE 2>&1 | awk '$2=="ingress"{print}'|grep -q .; then
    $TC qdisc del dev $IFACE ingress
  fi

  if tc qdisc show dev $DEV root 2>/dev/null 1>&2; then
    $TC qdisc del dev $DEV root
  fi

  $IP link set dev $DEV down

  $IP link del $DEV type ifb

  for module in act_nssmirred qca_nss_qdisc act_mirred ifb; do
    if [ -d /sys/module/$module ]; then
      sqm_log "sqm_stop: Removing kernel module: $module"
      rmmod $module 2>>${OUTPUT_TARGET} || (sqm_error "Failed to remove kernel module $module" && return 1)
    fi
  done

  return 0
}

# vim: syntax=sh ts=4 sw=4 sts=4
